name: Deploy Foodgram

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/foodgram_backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build frontend
      run: |
        cd frontend
        npm ci --legacy-peer-deps
        GENERATE_SOURCEMAP=false CI=false npm run build
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: ${{ secrets.DOCKER_USERNAME }}/foodgram_frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Setup SSH key on server
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        password: ${{ secrets.SERVER_PASSWORD }}
        script: |
          # Создаем директорию .ssh если её нет
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Извлекаем публичный ключ из приватного
          echo "${{ secrets.SSH_KEY }}" > /tmp/temp_key
          chmod 600 /tmp/temp_key
          ssh-keygen -y -f /tmp/temp_key > /tmp/public_key
          
          # Добавляем публичный ключ в authorized_keys если его там нет
          if ! grep -Fq "$(cat /tmp/public_key)" ~/.ssh/authorized_keys 2>/dev/null; then
            cat /tmp/public_key >> ~/.ssh/authorized_keys
            chmod 600 ~/.ssh/authorized_keys
            echo "SSH key added successfully"
          else
            echo "SSH key already exists"
          fi
          
          # Удаляем временные файлы
          rm -f /tmp/temp_key /tmp/public_key
    
    - name: Deploy to server
      if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.HOST }}
        username: ${{ secrets.USERNAME }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /home/${{ secrets.USERNAME }}/foodgram/infra
          
          # Создаем .env.prod файл с секретами
          cat > .env.prod << EOF
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          DEBUG=False
          ALLOWED_HOSTS=${{ secrets.DOMAIN_NAME }},www.${{ secrets.DOMAIN_NAME }},localhost,127.0.0.1
          DB_ENGINE=django.db.backends.postgresql
          DB_NAME=${{ secrets.DB_NAME }}
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          DB_HOST=db
          DB_PORT=5432
          DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          EOF
          
          # Обновляем nginx конфигурацию с доменом
          sed -i 's/your-domain.com/${{ secrets.DOMAIN_NAME }}/g' nginx.prod.conf
          
          # Запускаем контейнеры
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d --build
          
          # Очищаем старые образы
          docker system prune -f
          
          # Устанавливаем SSL сертификат (если еще не установлен)
          if [ ! -f /etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem ]; then
            sudo certbot --nginx -d ${{ secrets.DOMAIN_NAME }} -d www.${{ secrets.DOMAIN_NAME }} --non-interactive --agree-tos --email ${{ secrets.EMAIL }}
            docker-compose -f docker-compose.prod.yml restart nginx
          fi
